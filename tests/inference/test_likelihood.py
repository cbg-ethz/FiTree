import jax
import numpy as np

from fitree._inference._wrapper import VectorizedTrees
from fitree._inference._likelihood import mlogp_one_node

tol = 1e-3
C_0 = 1e5
beta = 8.8
t = 60

def test_mlogp_one_node():
	
	# Test case 1: lambda_1 = 0, lambda_2 > 0
	expected_output = np.array([
        0.00296105481930962573679264846772817142200468794895707272472828500876831104041511578068343321459626535,
        0.002711784462836684232322813249328352780312706814478932160655950884287557685966659465298998096395924892,
        0.00247333554425904403688922995001807192554192076718485239695277749656116458776251761091313801867771381,
        0.002245738153051455529192524419274661796295427514417637428381628030942727128038696986125711034338324306,
        0.002029021058437020390179188908386982525427099981665687150081521096828870405380177539699957493240717131,
        0.001823211698938432271265432546906182321111344639670767946674748299909969110159750768060498606664339627,
        0.001628336172386190135422684788135976661163271176656990067806560881015219374653057844183913702366410692,
        0.001444419226387936699336604241680821534413108766735586401257059673381761031964851493378053146738871722,
        0.001271484249256174785096425737075375225657779251692207397476589296434784068942658254064028647777949521,
        0.001109553261370454410688038383269639164584475987319134499359364729306488118820845885754926262303878567,
        0.0009586469068838665980618553662676085444699042802585369741382430219081650317117508803269073233673074933,
        0.000818784445474775041446574239790825466289835394707530584289378591388402535445520416322547156964034739,
        0.0006899837431845768595454845869674748595423964412436056756555508989188603311523539524878521296558226418,
        0.0005722612592947915549967446930027041289195588804541777134638979199540427102300671358290884166653833943,
        0.0004656320195944772196984034555482903695783140676151826557772629509494337281942414520762077617283745883,
    ])

	N_trees = expected_output.shape[0]
	vec_trees = VectorizedTrees(
		cell_number=np.array(
			[(0.0, np.power(10, i / 2)) for i in range(N_trees)]
		),
		observed=np.array([(1, 1)] * N_trees),
		sampling_time=np.array([t] * N_trees),
		weight=np.array([1.0] * N_trees),
		node_id=np.array([0, 1], dtype=np.int32),
		parent_id=np.array([-1, 0], dtype=np.int32),
		alpha=np.array([beta, 9.2]),
		nu=np.array([3.1 / C_0, 1e-5]),
		lam=np.array([0.0, 9.2 - beta]),
		rho=np.array([3.1 / C_0 / beta, 1e-5 / 9.2]),
		phi=np.array([beta, 9.2 / (9.2 - beta)]),
		delta=np.array([0.0, 9.2 - beta]),
		r=np.array([2.0, 1.0]),
		gamma=np.array([0.0, 0.0]),
		N_trees=N_trees,
		n_nodes=2,
		beta=beta,
		C_s=1e9,
		C_0=C_0,
		C_min=1e3,
	)

	actual_output = jax.vmap(
        mlogp_one_node,
        in_axes=(
            VectorizedTrees(
                0,  # cell_number
                0,  # observed
                0,  # sampling_time
                0,  # weight
                None,  # node_id
                None,  # parent_id
                None,  # alpha
                None,  # nu
                None,  # lam
                None,  # rho
                None,  # phi
                None,  # delta
                None,  # r
                None,  # gamma
                None,  # N_trees
                None,  # n_nodes
                None,  # beta
                None,  # C_s
                None,  # C_0
                None,  # C_min
            ),
            None,
			None,
        ),
    )(vec_trees, 1, 0.01)

	assert np.allclose(actual_output, np.log(1.0 - expected_output), atol=tol)
	